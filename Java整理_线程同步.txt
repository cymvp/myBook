Java规定的是原始类型(比如int, long)的表数范围，而没有规定存储的字节数.所以java只是规定了int类型所能表达的数的大小,而没有规定要几个字节存储.

Java允许线程在自己的内存中保存某个变量的副本(为了提高性能)，该线程直接对这个副本进行操作，而其他线程对于这个变量的修改，该线程是看不到的.
实现上说，应该就是Java的线程在Cache中缓存了一份变量的副本，其他线程对变量在主内存中的修改，该线程是不知道的.

如果用volatile标识变量，就可以保证线程不能创建该变量的一个副本。这样就不会出现上面的情况.

但是volatile不能保证变量的互斥访问.因为对变量的修改，是几个机器指令组合完成的，volatile只能保证最后的存储是放到主存中.

Java的语言保证，对除了Long和Double之外的基本类型的赋值操作，都是原子操作.

由于上述机制，volatile+基本类型的原子操作，可以实现两个线程访问同一个变量的互斥性.

引用也是属于基本类型，对引用的赋值也是原子性的.

双检查模式之所以不安全，是因为Java的无序写入的问题: instance = new Foo();  可能会instance先被赋值，然后才会调用Foo()的构造函数.

疑问: 
  1 为何双检查模式使用的不是对象引用，而是int型之类的类型，就可以工作?
  2 两个线程读写一个基本类型，为何只有多处理器才会检查出问题?
    我觉得是因为单处理器不会出现上面说的：一个线程缓存住一个对象的副本，其他线程修改变量时，直接修改的是主存的变量值。因为从计算机原理来说,会先看该变量是否被载入了cache,如果已经载入，那么就会直接使用cache里的值；也就是说，从计算机角度，主存里的数据在cache里只有一份。所有线程对该变量的副本其实是只有一份.
    但是多处理器就不一样了，每个处理器都有一份cache，各个cache之间互相不知道.
    
    
同步:
  wait()方法是Object的，这个方法会释放自己占用的锁.
  如果线程进入了一个对象的synchronized方法()，则使用synchronized的方法都不能执行;除非是static方法.    

