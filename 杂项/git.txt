git reset HEAD file.txt: 就是将文件从暂存区移除, 该文件之前在哪个区,就回到哪个区; 比如文件之前在untracked区,就仍然变为是untracked的；如果文件之前在修改区，就仍然变为是已修改但为暂存的。

可以理解为：文件已经修改，那么放到工作目录；如果文件作了暂存，就进入暂存区，物理位置是git目录中的某个地方；如果文件作了提交，那么就会放到git目录中。文件已经进入跟踪，但是没有修改的，实际上还是属于以提交的文件，实际会放在git目录。


git branch: 列出当前本地仓库的所有branch.

git checkout branch名: 切换branch.


git checkout -b 新branch名: 创建并切换分支.

git checkout -b 新branch名 [远程名]/[分支名].

git remote 远程仓库

git remote -v，可以列出远程仓库地址。

git commit --amend 可以多次提交用一个commit.

git的理解:
 .git就对应一个数据仓库。
 git pull时必须要在一个本地branch下，然后从远端数据仓库的一个branch上拿数据。
 远端给的地址比如用git remote -v看到的，都是数据仓库的地址。branch的地址是不知道的。
 如果想用git pull拿一个分支的数据，用git pull "git://地址" 的方式，如果没有设置默认remote branch，就不能成功。
 而如果当前本地branch做了远端branch的跟踪，就可以用git pull来下载数据。
 
 默认远端分支名: master, 默认远端仓库名：origin
 
 git remote show “数据仓库名”， 这条语句是查看该远程数据仓库都有哪些分支。与git branch -r相似.

git branch -d hotfix

~/bin/repo sync baidu/packages/apps/UBC就可恢复某个有.git仓库的目录文件.
哪些目录有.git，有代码根目录的.repo/mainfest.xml来指定。

 git config --global --add alias.ci commit用来改名.
 git的配置文件在~/.gitconfig文件中。
 
 
 疑问:
  1 如果删除掉真个目录，在repo sync,那么之前的本地分支还有么
  2 gitk看到的有别的本地分支commit的纪录么?
  
  
  
	git ls-tree -l Id Id可以是tree对象或者是commit对象. 根据Id显示目录树.
	
	git cat-file -t Id： 获得Id对应的对象的类型.
	
	git cat-file -p Id: 获得Id对应的对象的详细信息.
	
	git write-tree:将残存区的文件写入对象库,并生成tree对象。 之后提交时，这个tree对象就是对应commit对象的目录树.
	
	git add 命令实际上是将文件写入到对象库，这样会生成一个Id, 然后暂存区的目录树会引用这个Id，也就指向Id对应的文件。
	
	暂存区其实始终就是一个目录树(Index), 当git commit时，会生成一个commitId对应的commit对象，并将暂存区的目录树写入对象库，然后commit对象引用这个目录树.
	
	commit对象->tree对象->文件对象.
	
	git diff commitId: 比较工作区和commitId的版本库的区别.
	git diff：比较工作区和暂存区的区别.
	git diff --cached 比较暂存区和HEAD版本库的区别.
	
	