Java源文件名必需与公有类的名字相同.

Java虚拟机从指定类的main方法开始执行.main方法必须为public, static的，void的.

import关键字可以导入一个特定的类或者整个包. 它的最大能力就是导入一个包的所有类，无法导入多个包.
  如果两个包中有同一个类名，那么最好的解决方式就是显示引用类名：java.util.Date date = .....;
import还可以导入类的静态方法或者静态域. System.out是静态域，不是静态方法.

public: public的意思就是任何类的任何方法都可以进行访问.

private: private的意思就是只有本类的方法才可以进行访问.

没有定义访问权限的的定西(类，方法，变量)可以被同一包中的所有方法访问.

super关键字的用法:
  
  super用于调用父类的方法.
    (1)调用父类的一般方法: super.fun()--> 相当于C++的this->Parent::fun()
    (2)调用父类的构造方法:必须是本类构造方法的第一条语句. 这和C++不一样.C++调用父类的构造方法一定是在子类的构造方法之前.相当于C++的初始化列表.
    
  Java中可以在一个构造方法中调用另一个构造方法: this(XXX);
  
  以上都说明, Java的构造方法只是单纯的调用，不会再里面像C++一样做很多编译器内部的事情.
  
  Java要求覆盖的方法，方法的返回类型一样，或者子类的返回类型是父类的返回类型的子类.
  
  子类覆盖父类的方法时，访问权限一定不能比父类相应的方法访问权限低. 这么规定的考虑原因是: 如果子类的方法比父类方法的访问权限还低,那么Parent->func()在编译阶段能过，就挡不下来.

final:
  修饰类:这个类不能被继承.
  修饰方法：子类不能覆盖这个方法.
  修饰域:这个域在构造方法之后就不允许再被修改，所以在构造方法调用完之前一定要初始化.如果没有构造方法，则需要在类定义中初始化.
  
  类的final域和接口的final域需要在定义时初始化，或者在构造方法中初始化。 不初始化会出错.   
  
  当一个方法声明为final，就类似C++的非虚函数。Java的编译器可以针对这种函数实施内联. Java不需要C++的inline关键字.
  
做实验发现:
  Java中，父类的private方法不能被覆盖.
  private的域也能在类的定义中被引用.
  
强制转换：
  1 Java的强制转换也只能发生在同一继承层次类，不像C++可以任意转换.
  2 应该使用instanceof来进行检查.
  
抽象类:
  使用abstract关键字修饰的类.
  抽象类不能被实例化，抽象类中可以定义方法和域.
  
对象包装器:
  指所有的基本类型，都有一个相应的类与之对应. 这些类是final的，不可变的.
  
  编译器会自动地打包拆包，也就是说，在需要Integer时，会将int转为Integer；在需要int时，会将Integer转为int.
  
  包装器比较的时候不要使用==，因为==还是在比较内存地址. 需要用equals()方法.
  
  Integer.parseInt(String)方法可以将String转为int.
  
  包装器是不可变的类，也就是类似于String,如果你试图改变它的值，它会在创建一个新的对象出来.
  
反射:
  object.getClass()方法可以返回一个Class类的实例.
  
  还可以通过Class.forName(String 类名)来得到Class的一个实例.
  
  类名.class也可以得到该类的Class类的实例.
  
  每个类都会有一个Class的实例对象.可以通过==来比较两个对象是否属于同一个类.这比instanceof要精确.
  
  接口:
  实现接口的类所定义的方法，需要和接口声明的方法完全一致，包括public, 返回值(精确)，参数.
  接口的访问控制权限和class一样，只能加public，或者不加.
  接口的方法一定是public的，所以声明方法时，可以不加public.但是类实现该方法时，一定要加public，以明确是在实现接口.
  接口不能有实例域和实例方法.   
  
  instanceof可以检查某个对象是否实现了某个接口.
  
  接口的域自动被定义为public static final 型.
  
  接口可以被扩展.
  
clone:
  为了防止类的设计者在本类方法中无知(不知道clone为浅拷贝)地调用clone()方法,所以在Object.clone()方法中做了是否implements Cloneable的判断，否的话则抛异常.
  
  Test::func(){
    Test t2 = t1.clone();
  }
  
  数据类型的clone()方法都是public的。
  
重载 :
  基本类型: 类型大的参数不能传给类型小的形参.
  重载方法不能通过返回值区分.  